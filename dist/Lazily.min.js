const Lazily=function(n){const e="IntersectionObserver"in window&&"MutationObserver"in window&&"Promise"in window,t=e?new MutationObserver(function(n){n.forEach(function(n){u(n.addedNodes,f),u(n.removedNodes,d)})}):n,o=e?new IntersectionObserver(function(n){n.forEach(function(n){if(n.isIntersecting){const e=n.target,t=s.get(e);t&&t.forEach(function(n){n(e)})}})}):n,i=e?new Promise(function(n){document.addEventListener("DOMContentLoaded",n),window.addEventListener("load",n)}):n,r=[],s=new Map,c=[];function u(n,e){[].slice.call(n).forEach(e)}function f(n){r.forEach(function(e){e(n)})}function d(n){n instanceof Element&&(s.delete(n),o.unobserve(n)),c.forEach(function(e){e(n)})}function a(n){if("function"!=typeof n)throw new Error("Please provide a valid function")}return e&&t.observe(document.documentElement,{childList:!0,subtree:!0}),{getObserved:function(n){const e=[];return s.forEach(function(t,o){-1!=t.indexOf(n)&&e.push(o)}),e},isSupported:function(){return e},observe:function(n,e){return n instanceof Element?(a(e),s.has(n)||(s.set(n,[]),o.observe(n)),s.get(n).push(e),this):this},onAdd:function(n){return a(n),r.push(n),this},onRemove:function(n){return a(n),removeElementHandlers.push(n),this},ready:function(){if(e)return i.then.apply(i,arguments)},unobserve:function(n,e){if(!s.has(n))return this;const t=s.get(n),i=t.indexOf(e);return-1!=i&&t.splice(i,1),0==t.length&&(s.delete(n),o.unobserve(n)),this}}}();