const Lazily=function(n){const e="IntersectionObserver"in window&&"MutationObserver"in window&&"Promise"in window,t=e?new MutationObserver(function(n){n.forEach(function(n){u(n.addedNodes,f),u(n.removedNodes,d)})}):n,o=e?new IntersectionObserver(function(n){n.forEach(function(n){if(n.isIntersecting){const e=n.target,t=s.get(e);t&&t.forEach(function(n){n(e)})}})}):n,i=e?new Promise(function(n){document.addEventListener("DOMContentLoaded",n),window.addEventListener("load",n)}):n,r=[],s=new Map,c=[];function u(n,e){[].slice.call(n).forEach(e)}function f(n){r.forEach(function(e){e(n)})}function d(n){n instanceof Element&&(s.delete(n),o.unobserve(n)),c.forEach(function(e){e(n)})}function a(n){if("function"!=typeof n)throw new Error("Please provide a valid function")}return e&&t.observe(document.documentElement,{childList:!0,subtree:!0}),{getObserved:function(n){if(!e)return[];const t=[];return s.forEach(function(e,o){-1!=e.indexOf(n)&&t.push(o)}),t},isSupported:function(){return e},observe:function(n,t){return e&&n instanceof Element?(a(t),s.has(n)||(s.set(n,[]),o.observe(n)),s.get(n).push(t),this):this},onAdd:function(n){return e?(a(n),r.push(n),this):this},onRemove:function(n){return e?(a(n),removeElementHandlers.push(n),this):this},ready:function(){if(e)return i.then.apply(i,arguments)},unobserve:function(n,t){if(!e||!s.has(n))return this;const i=s.get(n),r=i.indexOf(t);return-1!=r&&i.splice(r,1),0==i.length&&(s.delete(n),o.unobserve(n)),this}}}();