const Lazily=function(n){const e="IntersectionObserver"in window&&"MutationObserver"in window,t=e?new MutationObserver(function(n){n.forEach(function(n){s(n.addedNodes,u),s(n.removedNodes,f)})}):n,o=e?new IntersectionObserver(function(n){n.forEach(function(n){if(n.isIntersecting){const e=n.target,t=i.get(e);t&&t.forEach(function(n){n(e)})}})}):n,r=[],i=new Map,c=[];function s(n,e){[].slice.call(n).forEach(e)}function u(n){r.forEach(function(e){e(n)})}function f(n){i.delete(n),o.unobserve(n),c.forEach(function(e){e(n)})}function d(n){if("function"!=typeof n)throw new Error("Please provide a valid function")}return e&&t.observe(document.documentElement,{childList:!0,subtree:!0}),{getObserved:function(n){const e=[];return i.forEach(function(t,o){-1!=t.indexOf(n)&&e.push(o)}),e},isSupported:function(){return e},observe:function(n,e){return n instanceof Element?(d(e),i.has(n)||(i.set(n,[]),o.observe(n)),i.get(n).push(e),this):this},onAdd:function(n){return d(n),r.push(n),this},onRemove:function(n){return d(n),removeElementHandlers.push(n),this},unobserve:function(n,e){if(!i.has(n))return this;const t=i.get(n),r=t.indexOf(e);return-1!=r&&t.splice(r,1),0==t.length&&(i.delete(n),o.unobserve(n)),this}}}();